<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三角板旋转动态可视化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-toggle {
            background: #e9ecef;
            color: #495057;
        }

        .btn-toggle.active {
            background: #28a745;
            color: white;
        }

        .btn-toggle:hover {
            background: #dee2e6;
        }

        .btn-toggle.active:hover {
            background: #218838;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control label {
            font-size: 14px;
            color: #495057;
            font-weight: 500;
            min-width: 40px;
        }

        .speed-control input[type="range"] {
            width: 120px;
            height: 6px;
            -webkit-appearance: none;
            background: #dee2e6;
            border-radius: 3px;
            outline: none;
        }

        #timeSlider {
            width: 200px;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .speed-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
        }

        .canvas-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            background: #fafafa;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .info-card {
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .info-card h3 {
            font-size: 13px;
            color: #6c757d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-card .value {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }

        .info-card .value.blue { color: #007bff; }
        .info-card .value.orange { color: #fd7e14; }
        .info-card .value.green { color: #28a745; }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #495057;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-playing {
            background: #d4edda;
            color: #155724;
        }

        .status-paused {
            background: #fff3cd;
            color: #856404;
        }

        .status-completed {
            background: #d1ecf1;
            color: #0c5460;
        }

        .scene-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .scene-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: #e9ecef;
            color: #495057;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .scene-btn:hover {
            background: #dee2e6;
        }

        .scene-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .scene-description {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 12px 16px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>三角板旋转动态可视化 <span id="statusBadge" class="status-badge status-paused">已暂停</span></h1>
        
        <div class="scene-selector">
            <button class="scene-btn active" data-scene="1">场景一：初始状态</button>
            <button class="scene-btn" data-scene="2">场景二：第(1)问</button>
            <button class="scene-btn" data-scene="3">场景三：第(2)问</button>
            <button class="scene-btn" data-scene="4">场景四：第(3)问</button>
        </div>
        
        <div class="scene-description" id="sceneDescription">
            <strong>场景一：初始复位状态</strong><br>
            AOB：OA 垂直向上，OB 水平向右（静止）<br>
            COD：OC 垂直向上，OD 水平向左（静止）<br>
            此时 OA 与 OC 重合，OB 与 OD 成 180° 平角
        </div>
        
        <div class="controls">
            <button id="playPauseBtn" class="btn btn-primary">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path id="playIcon" d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                    <path id="pauseIcon" d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z" style="display: none;"/>
                </svg>
                <span id="playPauseText">播放</span>
            </button>
            
            <button id="resetBtn" class="btn btn-secondary">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                </svg>
                重置
            </button>
            
            <button id="trajectoryBtn" class="btn btn-toggle active">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                    <path d="M4.285 12.433a.5.5 0 0 0 .683-.183A3.498 3.498 0 0 1 8 10.5c1.295 0 2.426.703 3.032 1.75a.5.5 0 0 0 .866-.5A4.498 4.498 0 0 0 8 9.5a4.5 4.5 0 0 0-3.898 2.25.5.5 0 0 0 .183.683zM7 6.5C7 7.328 6.552 8 6 8s-1-.672-1-1.5S5.448 5 6 5s1 .672 1 1.5zm4 0c0 .828-.448 1.5-1 1.5s-1-.672-1-1.5S9.448 5 10 5s1 .672 1 1.5z"/>
                </svg>
                显示轨迹
            </button>
            
            <div class="speed-control">
                <label>速度:</label>
                <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                <span id="speedValue" class="speed-value">1.0x</span>
            </div>
            
            <div class="speed-control">
                <label>时间:</label>
                <input type="range" id="timeSlider" min="0" max="48" step="0.01" value="0">
                <span id="timeSliderValue" class="speed-value">0.00s</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 123, 255, 0.6); border: 2px solid #007bff;"></div>
                <span id="aobLegend">三角板 AOB (OA↑, OB→, 5°/s)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(253, 126, 20, 0.6); border: 2px solid #fd7e14;"></div>
                <span id="codLegend">三角板 COD (OC↑, OD←, 15°/s)</span>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="info-card">
                <h3>运行时间</h3>
                <div class="value" id="timeValue">0.00 秒</div>
            </div>
            <div class="info-card">
                <h3>AOB 旋转角度</h3>
                <div class="value blue" id="aobAngle">0.0°</div>
            </div>
            <div class="info-card">
                <h3>COD 旋转角度</h3>
                <div class="value orange" id="codAngle">0.0°</div>
            </div>
            <div class="info-card">
                <h3>总进度</h3>
                <div class="value green" id="progressValue">0%</div>
            </div>
        </div>
    </div>

    <script>
        // 场景配置
        const SCENES = {
            1: {
                name: '场景一：初始复位状态',
                description: '<strong>场景一：初始复位状态</strong><br>AOB：OA 垂直向上，OB 水平向右（静止）<br>COD：OC 垂直向上，OD 水平向左（静止）<br>此时 OA 与 OC 重合，OB 与 OD 成 180° 平角',
                aobSpeed: 0,
                codSpeed: 0,
                codDirection: 1,  // 1: 逆时针, -1: 顺时针
                maxTime: 0
            },
            2: {
                name: '场景二：第(1)问',
                description: '<strong>场景二：第(1)问 - 顺时针摆动</strong><br>COD 绕点 O 顺时针旋转<br>AOB 保持静止（OA 垂直向上，OB 水平向右）<br>当 ∠AOC=35° 时停止，观察 ∠BOD 的变化',
                aobSpeed: 0,
                codSpeed: 5,
                codDirection: -1,  // 顺时针
                maxTime: 7,  // 35°/5°每秒 = 7秒
                stopAngle: 35  // 当 ∠AOC = 35° 时停止
            },
            3: {
                name: '场景三：第(2)问',
                description: '<strong>场景三：第(2)问 - 逆时针单转</strong><br>AOB 保持静止（OA 垂直向上，OB 水平向右）<br>COD 绕点 O 逆时针旋转，速度 15°/秒<br>观察 OD 平分 ∠AOB 的时刻（旋转一周360°）',
                aobSpeed: 0,
                codSpeed: 15,
                codDirection: 1,  // 逆时针
                maxTime: 24,  // 360°/15°每秒 = 24秒
                targetAngle: 360
            },
            4: {
                name: '场景四：第(3)问',
                description: '<strong>场景四：第(3)问 - 逆时针双转追击</strong><br>两个三角板同时逆时针旋转<br>COD 快速旋转 15°/秒（两周720°）<br>AOB 慢速旋转 5°/秒（随 COD 停止）<br>观察 OC 平分 ∠AON 的时刻',
                aobSpeed: 5,
                codSpeed: 15,
                codDirection: 1,  // 逆时针
                maxTime: 48,  // 720°/15°每秒 = 48秒
                targetAngle: 720
            }
        };

        // 应用状态管理
        const state = {
            currentScene: 1,
            isPlaying: false,
            isCompleted: false,
            speedMultiplier: 1.0,
            showTrajectory: true,
            currentTime: 0,
            aobAngle: 0,  // AOB当前角度（度）
            codAngle: 0,  // COD当前角度（度）
            trajectories: {
                aob: [],
                cod: []
            }
        };

        // 绘图配置
        const CONFIG = {
            scale: 150,
            triangleSize: 100
        };

        // Canvas 相关变量
        let canvas, ctx;
        let centerX, centerY;
        let lastTimestamp = 0;
        let animationId = null;

        // 初始化 Canvas
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // 设置 Canvas 尺寸
            canvas.width = 1000;
            canvas.height = 700;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2 + 50;
            
            draw();
        }

        // 角度转弧度
        function toRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        // 计算旋转后的点坐标
        function rotatePoint(x, y, angle, cx, cy) {
            const radians = toRadians(angle);
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);
            
            const dx = x - cx;
            const dy = y - cy;
            
            return {
                x: cx + dx * cos - dy * sin,
                y: cy + dx * sin + dy * cos
            };
        }

        // 绘制坐标轴
        function drawAxes() {
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            
            // 绘制网格
            ctx.beginPath();
            for (let i = -canvas.width; i < canvas.width * 2; i += 50) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
            }
            for (let i = -canvas.height; i < canvas.height * 2; i += 50) {
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
            }
            ctx.stroke();
            
            // 绘制主坐标轴
            ctx.strokeStyle = '#adb5bd';
            ctx.lineWidth = 2;
            
            // X 轴
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(canvas.width - 50, centerY);
            ctx.stroke();
            
            // Y 轴
            ctx.beginPath();
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, canvas.height - 50);
            ctx.stroke();
            
            // 标注坐标轴
            ctx.fillStyle = '#6c757d';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('X', canvas.width - 40, centerY + 20);
            ctx.fillText('Y', centerX + 20, 60);
            
            // 标注原点
            ctx.fillText('O', centerX - 15, centerY + 20);
        }

        // 绘制三角形
        function drawTriangle(vertices, color, borderColor, label) {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            
            // 填充
            ctx.fillStyle = color;
            ctx.fill();
            
            // 边框
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // 标注顶点
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            vertices.forEach((v, i) => {
                const labels = label.split('');
                const offset = 20;
                let labelX, labelY;
                
                if (i === 0) {
                    labelX = centerX - 15;
                    labelY = centerY + 20;
                } else {
                    labelX = v.x;
                    labelY = v.y;
                    if (labelX < centerX) labelX -= 15;
                    else labelX += 15;
                    if (labelY < centerY) labelY -= 15;
                    else labelY += 15;
                }
                
                ctx.fillText(labels[i], labelX, labelY);
            });
        }

        // 绘制轨迹
        function drawTrajectory(points, color) {
            if (points.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制轨迹点
            points.forEach((point, index) => {
                if (index % Math.max(1, Math.floor(points.length / 50)) === 0) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            });
        }

        // 绘制角度标注
        function drawAngleAnnotation(startAngle, endAngle, color, label) {
            const radius = 60;
            const startRad = toRadians(startAngle);
            const endRad = toRadians(endAngle);
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startRad, endRad, endRad < startRad);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 角度文字
            const midAngle = (startAngle + endAngle) / 2;
            const textRadius = radius + 25;
            const textRad = toRadians(midAngle);
            const textX = centerX + textRadius * Math.cos(textRad);
            const textY = centerY - textRadius * Math.sin(textRad);
            
            ctx.fillStyle = color;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, textX, textY);
        }

        // 主绘制函数
        function draw() {
            const scene = SCENES[state.currentScene];
            
            // 清除画布
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制坐标轴
            drawAxes();
            
            // 计算三角板顶点 - 每个三角板作为刚体绕 O 点旋转
            // Canvas 坐标系：x 向右增大，y 向下增大
            // 逆时针旋转：角度增加，顺时针旋转：角度减小（在标准笛卡尔坐标系中）
            // 在 Canvas 中需要特殊处理
            
            // AOB 三角板（蓝色）
            // 初始状态（角度=0）：OA 垂直向上（-90°方向），OB 水平向右（0°方向）
            // 逆时针旋转：从 -90° 开始减小角度（向 -180°, -270° 方向）
            const aobAngle = -90 - state.aobAngle;  // 从 -90° 逆时针旋转
            const aobAngleRad = toRadians(aobAngle);
            
            // A 点：初始在 -90° 方向（正上方）
            const aobAx = centerX + CONFIG.triangleSize * Math.cos(aobAngleRad);
            const aobAy = centerY + CONFIG.triangleSize * Math.sin(aobAngleRad);
            
            // B 点：初始在 0° 方向（正右方）
            const aobBx = centerX + CONFIG.triangleSize * Math.cos(aobAngleRad + Math.PI / 2);
            const aobBy = centerY + CONFIG.triangleSize * Math.sin(aobAngleRad + Math.PI / 2);
            
            const aobVertices = [
                { x: centerX, y: centerY },  // O（旋转中心）
                { x: aobAx, y: aobAy },  // A
                { x: aobBx, y: aobBy }   // B
            ];
            
            // COD 三角板（橙色）
            // 初始状态（角度=0）：OC 垂直向上（-90°方向），OD 水平向左（180°方向）
            // ∠COD = 90°，所以 D 点相对于 C 点的夹角是 -90°（从-90°减去90° = -180°即180°，向左）
            // 根据场景决定旋转方向
            let codAngle;
            if (scene.codDirection === 1) {
                // 逆时针：从 -90° 开始减小角度
                codAngle = -90 - state.codAngle;
            } else {
                // 顺时针：从 -90° 开始增加角度
                codAngle = -90 + state.codAngle;
            }
            const codAngleRad = toRadians(codAngle);
            
            // C 点：初始在 -90° 方向（正上方）
            const codCx = centerX + CONFIG.triangleSize * Math.cos(codAngleRad);
            const codCy = centerY + CONFIG.triangleSize * Math.sin(codAngleRad);
            
            // D 点：相对于 C 点旋转 -90°（即 180° 方向，向左）
            const codDx = centerX + CONFIG.triangleSize * Math.cos(codAngleRad - Math.PI / 2);
            const codDy = centerY + CONFIG.triangleSize * Math.sin(codAngleRad - Math.PI / 2);
            
            const codVertices = [
                { x: centerX, y: centerY },  // O（旋转中心）
                { x: codCx, y: codCy },  // C
                { x: codDx, y: codDy }   // D
            ];
            
            // 绘制轨迹（如果启用）
            if (state.showTrajectory) {
                // AOB 轨迹（A点）
                if (state.trajectories.aob.length > 0) {
                    drawTrajectory(state.trajectories.aob, 'rgba(0, 123, 255, 0.5)');
                }
                // COD 轨迹（C点）
                if (state.trajectories.cod.length > 0) {
                    drawTrajectory(state.trajectories.cod, 'rgba(253, 126, 20, 0.5)');
                }
            }
            
            // 绘制 COD 三角板（橙色，在下层）
            drawTriangle(codVertices, 'rgba(253, 126, 20, 0.6)', '#fd7e14', 'COD');
            
            // 绘制 AOB 三角板（蓝色，在上层）
            drawTriangle(aobVertices, 'rgba(0, 123, 255, 0.6)', '#007bff', 'AOB');
            
            // 绘制角度标注
            // AOB 从 -90° 逆时针旋转
            const aobStartAngle = -90;
            const aobEndAngle = -90 - state.aobAngle;
            drawAngleAnnotation(aobStartAngle, aobEndAngle, '#007bff', `${state.aobAngle.toFixed(1)}°`);
            
            // COD 根据方向标注角度
            let codStartAngle = -90;
            let codEndAngle;
            if (scene.codDirection === 1) {
                // 逆时针
                codEndAngle = -90 - state.codAngle;
            } else {
                // 顺时针
                codEndAngle = -90 + state.codAngle;
            }
            drawAngleAnnotation(codStartAngle, codEndAngle, '#fd7e14', `${state.codAngle.toFixed(1)}°`);
            
            // 绘制直线 MN（水平线，通过点 O）
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(canvas.width - 50, centerY);
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = '#6c757d';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('MN', canvas.width - 40, centerY - 15);
            
            // 标注点 O 在 MN 上
            ctx.fillStyle = '#333';
            ctx.fillText('O', centerX - 15, centerY + 25);
        }

        // 更新显示信息
        function updateDisplay() {
            const scene = SCENES[state.currentScene];
            
            document.getElementById('timeValue').textContent = state.currentTime.toFixed(2) + ' 秒';
            document.getElementById('aobAngle').textContent = state.aobAngle.toFixed(1) + '°';
            document.getElementById('codAngle').textContent = state.codAngle.toFixed(1) + '°';
            
            const progress = scene.maxTime > 0 ? (state.currentTime / scene.maxTime * 100).toFixed(1) : '0';
            document.getElementById('progressValue').textContent = progress + '%';
            
            // 更新状态徽章
            const statusBadge = document.getElementById('statusBadge');
            if (state.isCompleted) {
                statusBadge.textContent = '已完成';
                statusBadge.className = 'status-badge status-completed';
            } else if (state.isPlaying) {
                statusBadge.textContent = '播放中';
                statusBadge.className = 'status-badge status-playing';
            } else {
                statusBadge.textContent = '已暂停';
                statusBadge.className = 'status-badge status-paused';
            }
        }

        // 动画循环
        function animate(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000; // 转换为秒
            lastTimestamp = timestamp;
            
            const scene = SCENES[state.currentScene];
            
            if (state.isPlaying && !state.isCompleted) {
                // 更新时间
                state.currentTime += deltaTime * state.speedMultiplier;
                
                // 计算角度（根据场景配置）
                state.aobAngle = scene.aobSpeed * state.currentTime;
                state.codAngle = scene.codSpeed * state.currentTime;
                
                // 记录轨迹点（每隔一定时间）
                if (state.showTrajectory && state.currentTime > 0) {
                    // AOB 的 A 点轨迹
                    if (scene.aobSpeed > 0) {
                        const aobAngle = -90 - state.aobAngle;
                        const aobAngleRad = toRadians(aobAngle);
                        const aobAx = centerX + CONFIG.triangleSize * Math.cos(aobAngleRad);
                        const aobAy = centerY + CONFIG.triangleSize * Math.sin(aobAngleRad);
                        
                        if (state.trajectories.aob.length === 0 || 
                            Math.abs(state.trajectories.aob[state.trajectories.aob.length - 1].x - aobAx) > 5) {
                            state.trajectories.aob.push({ x: aobAx, y: aobAy });
                        }
                    }
                    
                    // COD 的 C 点轨迹
                    if (scene.codSpeed > 0) {
                        let codAngle;
                        if (scene.codDirection === 1) {
                            codAngle = -90 - state.codAngle;
                        } else {
                            codAngle = -90 + state.codAngle;
                        }
                        const codAngleRad = toRadians(codAngle);
                        const codCx = centerX + CONFIG.triangleSize * Math.cos(codAngleRad);
                        const codCy = centerY + CONFIG.triangleSize * Math.sin(codAngleRad);
                        
                        if (state.trajectories.cod.length === 0 || 
                            Math.abs(state.trajectories.cod[state.trajectories.cod.length - 1].x - codCx) > 5) {
                            state.trajectories.cod.push({ x: codCx, y: codCy });
                        }
                    }
                }
                
                // 检查是否完成
                if (state.currentTime >= scene.maxTime) {
                    state.currentTime = scene.maxTime;
                    state.isPlaying = false;
                    state.isCompleted = true;
                    updatePlayPauseButton();
                }
                
                // 同步更新时间滑块
                document.getElementById('timeSlider').value = state.currentTime;
                document.getElementById('timeSliderValue').textContent = state.currentTime.toFixed(2) + 's';
                
                updateDisplay();
            }
            
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // 播放/暂停
        function togglePlayPause() {
            state.isPlaying = !state.isPlaying;
            updatePlayPauseButton();
        }

        // 更新播放/暂停按钮
        function updatePlayPauseButton() {
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            const text = document.getElementById('playPauseText');
            
            if (state.isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
                text.textContent = '暂停';
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                text.textContent = '播放';
            }
            
            updateDisplay();
        }

        // 重置
        function reset() {
            state.isPlaying = false;
            state.isCompleted = false;
            state.currentTime = 0;
            state.aobAngle = 0;
            state.codAngle = 0;
            state.trajectories.aob = [];
            state.trajectories.cod = [];
            
            // 重置时间滑块
            document.getElementById('timeSlider').value = 0;
            document.getElementById('timeSliderValue').textContent = '0.00s';
            
            updatePlayPauseButton();
            updateDisplay();
            draw();
        }

        // 切换轨迹显示
        function toggleTrajectory() {
            state.showTrajectory = !state.showTrajectory;
            const btn = document.getElementById('trajectoryBtn');
            btn.classList.toggle('active', state.showTrajectory);
            draw();
        }

        // 设置速度
        function setSpeed(value) {
            state.speedMultiplier = parseFloat(value);
            document.getElementById('speedValue').textContent = state.speedMultiplier.toFixed(1) + 'x';
        }

        // 设置时间（通过滑块拖动）
        function setTimeBySlider(value) {
            const scene = SCENES[state.currentScene];
            const newTime = parseFloat(value);
            const clampedTime = Math.min(Math.max(0, newTime), scene.maxTime);
            
            state.currentTime = clampedTime;
            state.aobAngle = scene.aobSpeed * state.currentTime;
            state.codAngle = scene.codSpeed * state.currentTime;
            
            // 检查是否完成
            if (state.currentTime >= scene.maxTime) {
                state.isCompleted = true;
            } else {
                state.isCompleted = false;
            }
            
            // 更新轨迹（只保留当前时间点之前的轨迹）
            updateTrajectoryForTime(state.currentTime);
            
            document.getElementById('timeSliderValue').textContent = state.currentTime.toFixed(2) + 's';
            updateDisplay();
            draw();
        }

        // 根据时间更新轨迹点
        function updateTrajectoryForTime(time) {
            const scene = SCENES[state.currentScene];
            const steps = Math.floor(time * 2); // 每0.5秒一个轨迹点
            
            state.trajectories.aob = [];
            state.trajectories.cod = [];
            
            for (let t = 0; t <= time; t += 0.5) {
                // AOB 轨迹
                if (scene.aobSpeed > 0) {
                    const aobAngle = -90 - scene.aobSpeed * t;
                    const aobAngleRad = toRadians(aobAngle);
                    const aobAx = centerX + CONFIG.triangleSize * Math.cos(aobAngleRad);
                    const aobAy = centerY + CONFIG.triangleSize * Math.sin(aobAngleRad);
                    state.trajectories.aob.push({ x: aobAx, y: aobAy });
                }
                
                // COD 轨迹
                if (scene.codSpeed > 0) {
                    let codAngle;
                    if (scene.codDirection === 1) {
                        codAngle = -90 - scene.codSpeed * t;
                    } else {
                        codAngle = -90 + scene.codSpeed * t;
                    }
                    const codAngleRad = toRadians(codAngle);
                    const codCx = centerX + CONFIG.triangleSize * Math.cos(codAngleRad);
                    const codCy = centerY + CONFIG.triangleSize * Math.sin(codAngleRad);
                    state.trajectories.cod.push({ x: codCx, y: codCy });
                }
            }
        }

        // 切换场景
        function switchScene(sceneId) {
            state.currentScene = parseInt(sceneId);
            const scene = SCENES[state.currentScene];
            
            // 更新场景描述
            document.getElementById('sceneDescription').innerHTML = scene.description;
            
            // 更新按钮状态
            document.querySelectorAll('.scene-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.scene) === state.currentScene);
            });
            
            // 更新图例
            const aobSpeedText = scene.aobSpeed === 0 ? '静止' : scene.aobSpeed + '°/s';
            const codSpeedText = scene.codSpeed === 0 ? '静止' : scene.codSpeed + '°/s ' + (scene.codDirection === 1 ? '逆时针' : '顺时针');
            document.getElementById('aobLegend').textContent = `三角板 AOB (OA↑, OB→, ${aobSpeedText})`;
            document.getElementById('codLegend').textContent = `三角板 COD (OC↑, OD←, ${codSpeedText})`;
            
            // 更新时间滑块最大值
            document.getElementById('timeSlider').max = scene.maxTime;
            document.getElementById('timeSlider').value = 0;
            
            // 重置状态
            reset();
        }

        // 事件监听器
        document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('trajectoryBtn').addEventListener('click', toggleTrajectory);
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            setSpeed(e.target.value);
        });
        
        // 时间滑块事件
        document.getElementById('timeSlider').addEventListener('input', (e) => {
            // 拖动时暂停播放
            if (state.isPlaying) {
                togglePlayPause();
            }
            setTimeBySlider(e.target.value);
        });
        
        // 场景切换事件
        document.querySelectorAll('.scene-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchScene(btn.dataset.scene);
            });
        });

        // 初始化
        window.addEventListener('load', () => {
            initCanvas();
            // 初始化场景1的图例
            const scene1 = SCENES[1];
            document.getElementById('sceneDescription').innerHTML = scene1.description;
            const aobSpeedText = scene1.aobSpeed === 0 ? '静止' : scene1.aobSpeed + '°/s';
            const codSpeedText = scene1.codSpeed === 0 ? '静止' : scene1.codSpeed + '°/s ' + (scene1.codDirection === 1 ? '逆时针' : '顺时针');
            document.getElementById('aobLegend').textContent = `三角板 AOB (OA↑, OB→, ${aobSpeedText})`;
            document.getElementById('codLegend').textContent = `三角板 COD (OC↑, OD←, ${codSpeedText})`;
            updateDisplay();
            animationId = requestAnimationFrame(animate);
        });

        // 窗口大小改变时重绘
        window.addEventListener('resize', () => {
            initCanvas();
        });
    </script>
</body>
</html>
